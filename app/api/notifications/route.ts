import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/lib/auth';

// Bildirim t√ºrleri
enum NotificationType {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  SUCCESS = 'success',
}

// Bildirim kaynaklarƒ±
enum NotificationSource {
  EQUIPMENT = 'EQUIPMENT',
  INVENTORY = 'INVENTORY',
  TASK = 'TASK',
  VOLUNTEER = 'VOLUNTEER',
  PERSONNEL = 'PERSONNEL',
  SYSTEM = 'SYSTEM',
}

// Bildirim durumu
enum NotificationStatus {
  READ = 'read',
  UNREAD = 'unread',
  ARCHIVED = 'archived',
}

// Demo bildirim verileri
const mockNotifications = [
  {
    id: '1',
    title: 'D√º≈ü√ºk Stok Uyarƒ±sƒ±: N95 Maske',
    message: 'N95 Maske stok seviyesi 50 adete d√º≈üt√º (minimum: 100)',
    type: NotificationType.WARNING,
    source: NotificationSource.INVENTORY,
    status: NotificationStatus.UNREAD,
    createdAt: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/inventory',
    action: 'Stok Ekle'
  },
  {
    id: '2',
    title: 'Ekipman Bakƒ±m Zamanƒ±',
    message: 'Jenerat√∂r X5000 i√ßin planlanan bakƒ±m tarihi geldi',
    type: NotificationType.INFO,
    source: NotificationSource.EQUIPMENT,
    status: NotificationStatus.UNREAD,
    createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/equipment',
    action: 'Bakƒ±m Planla'
  },
  {
    id: '3',
    title: 'Son Kullanma Tarihi Yakla≈üƒ±yor',
    message: 'Hazƒ±r Gƒ±da Paketi √ºr√ºn√º i√ßin son kullanma tarihi 30 g√ºn i√ßinde',
    type: NotificationType.WARNING,
    source: NotificationSource.INVENTORY,
    status: NotificationStatus.UNREAD,
    createdAt: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/inventory',
  },
  {
    id: '4',
    title: 'Gecikmi≈ü G√∂rev',
    message: 'Afet b√∂lgesi deƒüerlendirme raporu teslim tarihi ge√ßti',
    type: NotificationType.ERROR,
    source: NotificationSource.TASK,
    status: NotificationStatus.UNREAD,
    createdAt: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/tasks',
    action: 'G√∂reve Git'
  },
  {
    id: '5',
    title: 'Yeni Eƒüitim ƒ∞√ßeriƒüi',
    message: 'G√∂n√ºll√ºler i√ßin yeni bir eƒüitim videosu eklendi: ƒ∞lk Yardƒ±m Temel Eƒüitimi',
    type: NotificationType.SUCCESS,
    source: NotificationSource.VOLUNTEER,
    status: NotificationStatus.READ,
    createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/volunteers/training',
    action: 'ƒ∞√ßeriƒüi G√∂r'
  },
  {
    id: '6',
    title: 'Ekipman Arƒ±zasƒ± Bildirimi',
    message: 'Taktik Telsiz Seti arƒ±za bildirimi yapƒ±ldƒ±',
    type: NotificationType.ERROR,
    source: NotificationSource.EQUIPMENT,
    status: NotificationStatus.READ,
    createdAt: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/equipment',
    action: 'Arƒ±za Kaydƒ±nƒ± G√∂r'
  },
  {
    id: '7',
    title: 'Yeni G√∂rev Atandƒ±',
    message: 'Size yeni bir g√∂rev atandƒ±: Saha ekibi koordinasyonu',
    type: NotificationType.INFO,
    source: NotificationSource.TASK,
    status: NotificationStatus.UNREAD,
    createdAt: new Date(Date.now() - 12 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/tasks',
    action: 'G√∂reve Git'
  },
  {
    id: '8',
    title: 'ƒ∞zin Talebi Onaylandƒ±',
    message: 'Mehmet Demir i√ßin izin talebi onaylandƒ±: 15-20 Kasƒ±m 2023',
    type: NotificationType.SUCCESS,
    source: NotificationSource.PERSONNEL,
    status: NotificationStatus.READ,
    createdAt: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/personnel',
  },
  {
    id: '9',
    title: 'Sistem Bakƒ±mƒ± Planlandƒ±',
    message: 'Sistem bakƒ±mƒ± nedeniyle platform 24 Kasƒ±m 02:00-05:00 saatleri arasƒ±nda hizmet vermeyecektir',
    type: NotificationType.INFO,
    source: NotificationSource.SYSTEM,
    status: NotificationStatus.UNREAD,
    createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
  },
  {
    id: '10',
    title: 'Yeni G√∂n√ºll√º Ba≈üvurusu',
    message: '5 yeni g√∂n√ºll√º ba≈üvurusu deƒüerlendirme bekliyor',
    type: NotificationType.INFO,
    source: NotificationSource.VOLUNTEER,
    status: NotificationStatus.UNREAD,
    createdAt: new Date(Date.now() - 6 * 60 * 60 * 1000).toISOString(),
    link: '/dashboard/volunteers',
    action: 'Ba≈üvurularƒ± ƒ∞ncele'
  }
];

// GET - Bildirimleri getir
export async function GET(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status');
    const source = searchParams.get('source');
    const limit = searchParams.get('limit');
    const isStats = searchParams.get('stats') === 'true';

    // Stats endpoint
    if (isStats) {
      const stats = {
        all: mockNotifications.length,
        unread: mockNotifications.filter(n => n.status === NotificationStatus.UNREAD).length,
        read: mockNotifications.filter(n => n.status === NotificationStatus.READ).length,
        warning: mockNotifications.filter(n => n.type === NotificationType.WARNING).length,
        error: mockNotifications.filter(n => n.type === NotificationType.ERROR).length,
        info: mockNotifications.filter(n => n.type === NotificationType.INFO).length,
        success: mockNotifications.filter(n => n.type === NotificationType.SUCCESS).length,
        inventory: mockNotifications.filter(n => n.source === NotificationSource.INVENTORY).length,
        equipment: mockNotifications.filter(n => n.source === NotificationSource.EQUIPMENT).length,
        tasks: mockNotifications.filter(n => n.source === NotificationSource.TASK).length,
        volunteers: mockNotifications.filter(n => n.source === NotificationSource.VOLUNTEER).length,
        personnel: mockNotifications.filter(n => n.source === NotificationSource.PERSONNEL).length,
        system: mockNotifications.filter(n => n.source === NotificationSource.SYSTEM).length
      };
      
      return NextResponse.json({ stats });
    }

    // Filter notifications
    let filteredNotifications = [...mockNotifications];

    if (status) {
      filteredNotifications = filteredNotifications.filter(n => 
        n.status.toLowerCase() === status.toLowerCase()
      );
    }

    if (source) {
      filteredNotifications = filteredNotifications.filter(n => 
        n.source === source.toUpperCase()
      );
    }

    // Apply limit
    if (limit) {
      const limitNum = parseInt(limit);
      filteredNotifications = filteredNotifications.slice(0, limitNum);
    }

    // Sort by creation date (newest first)
    filteredNotifications.sort((a, b) => 
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );

    return NextResponse.json({
      notifications: filteredNotifications,
      total: filteredNotifications.length
    });

  } catch (error) {
    console.error('Bildirimler alƒ±nƒ±rken hata:', error);
    return NextResponse.json(
      { error: 'Bildirimler alƒ±namadƒ±' },
      { status: 500 }
    );
  }
}

// POST - Yeni bildirim olu≈ütur
export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const data = await request.json();
    
    // Gerekli alanlarƒ± kontrol et
    if (!data.title || !data.description || !data.type || !data.emergencyType) {
      return NextResponse.json(
        { error: 'Ba≈ülƒ±k, a√ßƒ±klama, t√ºr ve acil durum t√ºr√º gerekli' },
        { status: 400 }
      );
    }

    // Yeni bildirim olu≈ütur
    const newNotification = {
      id: (mockNotifications.length + 1).toString(),
      title: data.title,
      message: data.description,
      type: data.type,
      source: data.source || NotificationSource.SYSTEM,
      status: NotificationStatus.UNREAD,
      createdAt: new Date().toISOString(),
      emergencyType: data.emergencyType,
      location: data.location,
      coordinates: data.coordinates,
      targetGroup: data.targetGroup,
      urgent: data.urgent || false,
      scheduledAt: data.scheduledAt,
      expiresAt: data.expiresAt,
      createdBy: data.createdBy,
      link: getNotificationLink(data.emergencyType),
      action: getNotificationAction(data.emergencyType)
    };

    // Mock verilere ekle (ger√ßek uygulamada veritabanƒ±na kaydedilecek)
    mockNotifications.unshift(newNotification);

    // Bildirim g√∂nderme sim√ºlasyonu
    console.log(`üì¢ Yeni bildirim olu≈üturuldu: ${newNotification.title}`);
    console.log(`üéØ Hedef grup: ${data.targetGroup}`);
    console.log(`üìç Konum: ${data.location}`);
    
    return NextResponse.json({
      success: true,
      notification: newNotification,
      message: 'Bildirim ba≈üarƒ±yla olu≈üturuldu ve g√∂nderildi'
    });

  } catch (error) {
    console.error('Bildirim olu≈üturulurken hata:', error);
    return NextResponse.json(
      { error: 'Bildirim olu≈üturulamadƒ±' },
      { status: 500 }
    );
  }
}

// PUT - Bildirim durumunu g√ºncelle
export async function PUT(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { id, status } = await request.json();

    if (!id || !status) {
      return NextResponse.json(
        { error: 'ID ve status gerekli' },
        { status: 400 }
      );
    }

    // Mock veri g√ºncelleme (ger√ßek uygulamada veritabanƒ± g√ºncellenecek)
    const notificationIndex = mockNotifications.findIndex(n => n.id === id);
    
    if (notificationIndex === -1) {
      return NextResponse.json(
        { error: 'Bildirim bulunamadƒ±' },
        { status: 404 }
      );
    }

    mockNotifications[notificationIndex].status = status.toLowerCase();

    return NextResponse.json({
      success: true,
      notification: mockNotifications[notificationIndex]
    });

  } catch (error) {
    console.error('Bildirim g√ºncellenirken hata:', error);
    return NextResponse.json(
      { error: 'Bildirim g√ºncellenemedi' },
      { status: 500 }
    );
  }
}

// Yardƒ±mcƒ± fonksiyonlar
function getNotificationLink(emergencyType: string): string {
  switch (emergencyType) {
    case 'earthquake':
      return '/dashboard/map';
    case 'fire':
      return '/dashboard/equipment';
    case 'flood':
      return '/dashboard/tasks';
    case 'storm':
      return '/dashboard/notifications';
    case 'exercise':
      return '/dashboard/volunteers';
    default:
      return '/dashboard/notifications';
  }
}

function getNotificationAction(emergencyType: string): string {
  switch (emergencyType) {
    case 'earthquake':
      return 'Haritayƒ± G√∂r';
    case 'fire':
      return 'Ekipleri G√∂r';
    case 'flood':
      return 'G√∂revleri G√∂r';
    case 'storm':
      return 'Detaylarƒ± G√∂r';
    case 'exercise':
      return 'Katƒ±l';
    default:
      return 'Detaylarƒ± G√∂r';
  }
} 
